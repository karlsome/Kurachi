
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>QR„Ç≥„Éº„ÉâÊØîËºÉ„ÉÑ„Éº„É´</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    /* Tailwind CSS Base Styles - Inlined for Offline Support */
    *, ::before, ::after { box-sizing: border-box; border-width: 0; border-style: solid; border-color: #e5e7eb; }
    ::before, ::after { --tw-content: ''; }
    html { line-height: 1.5; -webkit-text-size-adjust: 100%; -moz-tab-size: 4; tab-size: 4; font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; font-feature-settings: normal; font-variation-settings: normal; }
    body { margin: 0; line-height: inherit; }
    h1, h2, p, ul { margin: 0; }
    h1, h2 { font-size: inherit; font-weight: inherit; }
    button, input, select, textarea { font-family: inherit; font-size: 100%; font-weight: inherit; line-height: inherit; color: inherit; margin: 0; padding: 0; }
    button, select { text-transform: none; }
    button, [type='button'] { -webkit-appearance: button; appearance: button; background-color: transparent; background-image: none; }
    ul { list-style: none; padding: 0; }
    textarea { resize: vertical; }
    ::placeholder { opacity: 1; color: #9ca3af; }
    audio { display: inline-block; vertical-align: baseline; }
    [hidden] { display: none; }
    
    /* Tailwind Utilities - Inlined */
    .bg-gray-100 { background-color: #f3f4f6; }
    .bg-gray-50 { background-color: #f9fafb; }
    .bg-white { background-color: #ffffff; }
    .bg-blue-50 { background-color: #eff6ff; }
    .bg-blue-600 { background-color: #2563eb; }
    .bg-gray-500 { background-color: #6b7280; }
    .bg-purple-600 { background-color: #9333ea; }
    .bg-red-600 { background-color: #dc2626; }
    .hover\:bg-blue-700:hover { background-color: #1d4ed8; }
    .hover\:bg-gray-600:hover { background-color: #4b5563; }
    .hover\:bg-purple-700:hover { background-color: #7e22ce; }
    .border { border-width: 1px; }
    .border-gray-300 { border-color: #d1d5db; }
    .rounded-lg { border-radius: 0.5rem; }
    .rounded-xl { border-radius: 0.75rem; }
    .rounded-2xl { border-radius: 1rem; }
    .flex { display: flex; }
    .items-center { align-items: center; }
    .justify-center { justify-content: center; }
    .font-bold { font-weight: 700; }
    .font-semibold { font-weight: 600; }
    .font-medium { font-weight: 500; }
    .text-xs { font-size: 0.75rem; line-height: 1rem; }
    .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
    .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
    .text-xl { font-size: 1.25rem; line-height: 1.75rem; }
    .text-2xl { font-size: 1.5rem; line-height: 2rem; }
    .text-3xl { font-size: 1.875rem; line-height: 2.25rem; }
    .gap-2 { gap: 0.5rem; }
    .min-h-screen { min-height: 100vh; }
    .max-h-64 { max-height: 16rem; }
    .max-w-2xl { max-width: 42rem; }
    .w-full { width: 100%; }
    .mb-2 { margin-bottom: 0.5rem; }
    .mb-4 { margin-bottom: 1rem; }
    .mb-6 { margin-bottom: 1.5rem; }
    .mt-1 { margin-top: 0.25rem; }
    .mt-4 { margin-top: 1rem; }
    .mt-6 { margin-top: 1.5rem; }
    .my-6 { margin-top: 1.5rem; margin-bottom: 1.5rem; }
    .overflow-y-auto { overflow-y: auto; }
    .p-2 { padding: 0.5rem; }
    .p-3 { padding: 0.75rem; }
    .p-4 { padding: 1rem; }
    .p-8 { padding: 2rem; }
    .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
    .shadow-xl { box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1); }
    .space-y-2 > :not([hidden]) ~ :not([hidden]) { margin-top: 0.5rem; }
    .space-y-3 > :not([hidden]) ~ :not([hidden]) { margin-top: 0.75rem; }
    .text-center { text-align: center; }
    .text-blue-600 { color: #2563eb; }
    .text-gray-500 { color: #6b7280; }
    .text-gray-600 { color: #4b5563; }
    .text-gray-700 { color: #374151; }
    .text-gray-800 { color: #1f2937; }
    .text-green-600 { color: #16a34a; }
    .text-red-600 { color: #dc2626; }
    .text-white { color: #ffffff; }
    .transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }
    .duration-200 { transition-duration: 200ms; }
    .block { display: block; }
    .resize-none { resize: none; }
    
    /* Custom Styles */
    @keyframes flash-red {
      0%, 100% { background-color: rgba(255, 0, 0, 0.1); }
      50% { background-color: rgba(255, 0, 0, 0.8); }
    }
    
    .flash-red {
      animation: flash-red 0.7s infinite;
    }
    
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .modal-content {
      background: white;
      padding: 2rem;
      border-radius: 1rem;
      max-width: 550px;
      width: 90%;
      max-height: 95vh;
      text-align: center;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
    }
    
    @media (max-height: 800px) {
      .modal-content {
        padding: 1.5rem;
      }
      .modal-content h2 {
        font-size: 1.75rem;
        margin-bottom: 0.75rem;
      }
      .modal-content p {
        font-size: 0.95rem;
        margin-bottom: 0.75rem;
      }
    }
    
    @media (max-height: 700px) {
      .modal-content {
        padding: 1.25rem;
      }
      .modal-content h2 {
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
      }
      .modal-content p {
        font-size: 0.9rem;
        margin-bottom: 0.5rem;
      }
      .instruction-step {
        margin-bottom: 0.4rem;
        padding: 0.3rem;
        font-size: 0.85rem;
      }
      .modal-button {
        padding: 0.5rem 1.5rem;
        font-size: 0.9rem;
        margin-top: 0.75rem;
      }
      .space-y-3 {
        gap: 0.4rem;
      }
    }
    
    @media (max-height: 600px) {
      .modal-content {
        padding: 1rem;
      }
      .modal-content h2 {
        font-size: 1.25rem;
        margin-bottom: 0.4rem;
      }
      .modal-content p {
        font-size: 0.8rem;
        margin-bottom: 0.4rem;
      }
      .instruction-step {
        margin-bottom: 0.3rem;
        padding: 0.25rem;
        font-size: 0.75rem;
      }
      .modal-button {
        padding: 0.4rem 1.25rem;
        font-size: 0.85rem;
        margin-top: 0.5rem;
      }
    }
    
    @media (max-height: 500px) {
      .modal-content {
        padding: 0.75rem;
      }
      .modal-content h2 {
        font-size: 1.1rem;
        margin-bottom: 0.3rem;
      }
      .modal-content p {
        font-size: 0.7rem;
        margin-bottom: 0.3rem;
      }
      .instruction-step {
        margin-bottom: 0.2rem;
        padding: 0.2rem;
        font-size: 0.65rem;
      }
      .instruction-step .step-number {
        width: 1.2rem;
        height: 1.2rem;
        font-size: 0.7rem;
      }
      .modal-button {
        padding: 0.35rem 1rem;
        font-size: 0.75rem;
        margin-top: 0.4rem;
      }
    }
    
    @media (max-height: 400px) {
      .modal-content {
        padding: 0.5rem;
      }
      .modal-content h2 {
        font-size: 1rem;
        margin-bottom: 0.25rem;
      }
      .modal-content p {
        font-size: 0.65rem;
        margin-bottom: 0.25rem;
      }
      .instruction-step {
        margin-bottom: 0.15rem;
        padding: 0.15rem;
        font-size: 0.6rem;
      }
      .instruction-step .step-number {
        width: 1rem;
        height: 1rem;
        font-size: 0.6rem;
        margin-right: 0.3rem;
      }
      .modal-button {
        padding: 0.3rem 0.75rem;
        font-size: 0.7rem;
        margin-top: 0.3rem;
      }
    }
    
    .mismatch-modal .modal-content {
      border-left: 8px solid #ef4444;
    }
    
    .welcome-modal .modal-content {
      border-left: 8px solid #3b82f6;
    }
    
    .modal-button {
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 0.5rem;
      font-weight: bold;
      margin-top: 1rem;
      cursor: pointer;
      transition: background-color 0.2s;
      color: white;
    }
    
    .modal-button.red {
      background: #ef4444;
    }
    
    .modal-button.red:hover {
      background: #dc2626;
    }
    
    .modal-button.blue {
      background: #3b82f6;
    }
    
    .modal-button.blue:hover {
      background: #2563eb;
    }
    
    .instruction-step {
      text-align: left;
      margin-bottom: 1rem;
      padding: 0.5rem;
      border-radius: 0.5rem;
      background: #f3f4f6;
    }
    
    .instruction-step .step-number {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 1.5rem;
      height: 1.5rem;
      background: #3b82f6;
      color: white;
      border-radius: 50%;
      margin-right: 0.5rem;
      font-weight: bold;
      font-size: 0.875rem;
    }
    
    /* Custom Dropdown Styles for Offline Support */
    .custom-dropdown {
      position: relative;
      width: 100%;
    }
    
    .custom-dropdown-button {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 0.5rem;
      background: white;
      text-align: left;
      font-size: 1.125rem;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.2s;
    }
    
    .custom-dropdown-button:hover {
      border-color: #3b82f6;
      background: #f9fafb;
    }
    
    .custom-dropdown-button:active {
      background: #f3f4f6;
    }
    
    .custom-dropdown-arrow {
      transition: transform 0.2s;
      font-size: 0.75rem;
    }
    
    .custom-dropdown.open .custom-dropdown-arrow {
      transform: rotate(180deg);
    }
    
    .custom-dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      margin-top: 0.25rem;
      background: white;
      border: 1px solid #d1d5db;
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      z-index: 100;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    
    .custom-dropdown.open .custom-dropdown-menu {
      max-height: 300px;
      overflow-y: auto;
    }
    
    .custom-dropdown-option {
      padding: 0.75rem;
      cursor: pointer;
      font-size: 1.125rem;
      font-weight: 500;
      transition: background 0.15s;
      border-bottom: 1px solid #f3f4f6;
    }
    
    .custom-dropdown-option:last-child {
      border-bottom: none;
    }
    
    .custom-dropdown-option:hover {
      background: #eff6ff;
    }
    
    .custom-dropdown-option:active {
      background: #dbeafe;
    }
    
    .custom-dropdown-option.selected {
      background: #3b82f6;
      color: white;
      font-weight: 600;
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4 text-lg">
  <!-- Audio element for alert sound -->
  <audio id="alert-sound" src="src/alert.mp3" preload="auto"></audio>
  <!-- Audio element for success sound -->
  <audio id="success-sound" src="src/success.mp3" preload="auto"></audio>
  
  <!-- Welcome Modal -->
  <div id="welcomeModal" class="modal-overlay welcome-modal">
    <div class="modal-content">
      <h2 class="text-2xl font-bold text-blue-600 mb-4">QR„Ç≥„Éº„ÉâÊØîËºÉ„ÉÑ„Éº„É´„Å∏„Çà„ÅÜ„Åì„Åù</h2>
      
      <div class="space-y-3 my-6">
        <div class="instruction-step">
          <span class="step-number">1</span>
          <span>„Éê„Éº„Ç≥„Éº„Éâ„Çπ„Ç≠„É£„Éä„Éº„Åß„ÅäÂÆ¢ÊßòQR„Ç≥„Éº„Éâ„Çí„Çπ„Ç≠„É£„É≥„Åó„Åæ„Åô</span>
        </div>
        <div class="instruction-step">
          <span class="step-number">2</span>
          <span>Á∂ö„ÅÑ„Å¶„ÄÅÁ§æÂÜÖQR„Ç≥„Éº„Éâ„Çí„Çπ„Ç≠„É£„É≥„Åó„Åæ„Åô</span>
        </div>
        <div class="instruction-step">
          <span class="step-number">3</span>
          <span>‰∏°Êñπ„Çπ„Ç≠„É£„É≥„Åô„Çã„Å®Ëá™ÂãïÁöÑ„Å´ÊØîËºÉ„Åó„Åæ„Åô</span>
        </div>
        <div class="instruction-step">
          <span class="step-number">4</span>
          <span>‰∏ç‰∏ÄËá¥„ÅÆÂ†¥Âêà„ÅØË≠¶ÂëäÈü≥„Å®ÁîªÈù¢Ë°®Á§∫„Åß„ÅäÁü•„Çâ„Åõ„Åó„Åæ„Åô</span>
        </div>
      </div>
      
      <p class="text-sm text-gray-600 mb-4">„Äå„Çπ„Ç≠„É£„É≥ÈñãÂßã„Äç„Éú„Çø„É≥„ÇíÊäº„Åó„Å¶„ÄÅ„Çπ„Ç≠„É£„É≥„ÇíÈñãÂßã„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
      <button id="startButton" class="modal-button blue">„Çπ„Ç≠„É£„É≥ÈñãÂßã</button>
    </div>
  </div>
  
  <!-- Mismatch Alert Modal -->
  <div id="mismatchModal" class="modal-overlay mismatch-modal" style="display:none;">
    <div class="modal-content">
      <h2 class="text-2xl font-bold text-red-600 mb-4">‚ö†Ô∏è QR„Ç≥„Éº„Éâ‰∏ç‰∏ÄËá¥</h2>
      <p id="mismatchMessage" class="mb-4 text-lg"></p>
      <p class="text-gray-600 mb-6">Á¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇQR„Ç≥„Éº„Éâ„ÅåÁï∞„Å™„Çä„Åæ„Åô„ÄÇ</p>
      <button class="modal-button red" onclick="closeMismatchModal()">Á¢∫Ë™ç</button>
    </div>
  </div>
  
  <div class="bg-white rounded-2xl shadow-xl p-8 max-w-2xl w-full">
    <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">QR„Ç≥„Éº„ÉâÊØîËºÉv2</h1>
    
    <!-- Customer Selection Dropdown -->
    <div class="mb-6">
      <label class="block text-sm font-semibold text-gray-600 mb-2">„ÅäÂÆ¢ÊßòÈÅ∏Êäû</label>
      <div class="custom-dropdown" id="customerDropdown">
        <button type="button" class="custom-dropdown-button" id="customerDropdownButton">
          <span id="customerDropdownSelected">„ÉÜ„Ç£„Éº„Ç®„ÉåË£Ω‰ΩúÊâÄ</span>
          <span class="custom-dropdown-arrow">‚ñº</span>
        </button>
        <div class="custom-dropdown-menu" id="customerDropdownMenu">
          <div class="custom-dropdown-option selected" data-value="tn">„ÉÜ„Ç£„Éº„Ç®„ÉåË£Ω‰ΩúÊâÄ</div>
          <div class="custom-dropdown-option" data-value="toyota">„Éà„É®„ÇøÁ¥°Áπî</div>
          <div class="custom-dropdown-option" data-value="kinuura">Ë°£Êµ¶</div>
        </div>
      </div>
      <!-- Hidden input to maintain compatibility with existing JS -->
      <input type="hidden" id="customerSelect" value="tn">
    </div>
    
    <!-- Online/Offline Status Indicator -->
    <div id="onlineStatus" class="text-center text-xs font-medium mb-2 p-2 rounded-lg" style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
      <span id="onlineStatusText"></span>
      <button id="toggleOfflineBtn" onclick="toggleOfflineMode()" style="padding: 0.25rem 0.75rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 600; border: none; cursor: pointer; transition: all 0.2s;">
        „Ç™„Éï„É©„Ç§„É≥„É¢„Éº„ÉâÂàáÊõø
      </button>
    </div>
    
    <!-- Scan Status -->
    <div id="scanStatus" class="text-center text-sm font-medium text-blue-600 mb-6 p-2 bg-blue-50 rounded-lg">
      „Çπ„Ç≠„É£„É≥ÂæÖÊ©ü‰∏≠...
    </div>

    <div class="mb-4">
      <label for="customerQR" class="block text-sm font-semibold text-gray-600">„ÅäÂÆ¢ÊßòQR</label>
      <textarea id="customerQR" rows="2" placeholder="„ÅäÂÆ¢Êßò„ÅÆQR„Ç≥„Éº„Éâ„Åå„Åì„Åì„Å´Ëá™ÂãïË°®Á§∫„Åï„Çå„Åæ„Åô"
        class="mt-1 p-3 w-full border rounded-lg bg-gray-50 resize-none" readonly></textarea>
    </div>

    <div class="mb-4">
      <label for="ourQR" class="block text-sm font-semibold text-gray-600">ÂºäÁ§æQR</label>
      <textarea id="ourQR" rows="2" placeholder="ÂºäÁ§æ„ÅÆQR„Ç≥„Éº„Éâ„Åå„Åì„Åì„Å´Ëá™ÂãïË°®Á§∫„Åï„Çå„Åæ„Åô"
        class="mt-1 p-3 w-full border rounded-lg bg-gray-50 resize-none" readonly></textarea>
    </div>

    <div class="flex gap-2 mb-4">
      <button onclick="compareQRs()"
        class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 rounded-xl transition duration-200">
        ÊâãÂãïÊØîËºÉ
      </button>
      <button onclick="clearFields()"
        class="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-semibold py-3 rounded-xl transition duration-200">
        „ÇØ„É™„Ç¢
      </button>
      <button id="learningModeBtn" onclick="openLearningMode()"
        class="flex-1 bg-purple-600 hover:bg-purple-700 text-white font-semibold py-3 rounded-xl transition duration-200">
        Â≠¶Áøí„É¢„Éº„Éâ
      </button>
    </div>

    <div id="result" class="mt-4 text-center text-lg font-semibold"></div>

    <div class="mt-6">
      <h2 class="text-lg font-medium text-gray-500 mb-2">„Çπ„Ç≠„É£„É≥„É≠„Ç∞:</h2>
      <ul id="logList" class="max-h-64 overflow-y-auto text-sm text-gray-700 space-y-2 bg-gray-50 p-4 rounded-lg border"></ul>
    </div>
  </div>

  <script>
    // Audio System with Offline Fallback
    (function() {
      const AudioSystem = {
        online: navigator.onLine,
        audioContext: null,
        
        init: function() {
          // Update online status
          window.addEventListener('online', () => {
            this.online = true;
            console.log('Audio: Online mode - using MP3 files');
          });
          
          window.addEventListener('offline', () => {
            this.online = false;
            console.log('Audio: Offline mode - using generated tones');
          });
          
          // Initialize Web Audio API for offline sounds
          try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.audioContext = new AudioContext();
          } catch (e) {
            console.error('Web Audio API not supported:', e);
          }
        },
        
        playSuccess: function() {
          if (this.online) {
            // Try to play MP3 file
            const audio = document.getElementById('success-sound');
            if (audio) {
              audio.muted = false;
              audio.volume = 1.0;
              audio.currentTime = 0;
              audio.play().catch(err => {
                console.log('MP3 playback failed, using fallback tone');
                this.playSuccessTone();
              });
            } else {
              this.playSuccessTone();
            }
          } else {
            // Use generated tone for offline
            this.playSuccessTone();
          }
        },
        
        playError: function() {
          if (this.online) {
            // Try to play MP3 file
            const audio = document.getElementById('alert-sound');
            if (audio) {
              audio.muted = false;
              audio.volume = 0.3;
              audio.currentTime = 0;
              audio.play().catch(err => {
                console.log('MP3 playback failed, using fallback tone');
                this.playErrorTone();
              });
            } else {
              this.playErrorTone();
            }
          } else {
            // Use generated tone for offline
            this.playErrorTone();
          }
        },
        
        playSuccessTone: function() {
          if (!this.audioContext) return;
          
          const ctx = this.audioContext;
          const now = ctx.currentTime;
          
          // Create pleasant success sound: two ascending tones
          // First tone: C (523.25 Hz)
          const osc1 = ctx.createOscillator();
          const gain1 = ctx.createGain();
          osc1.connect(gain1);
          gain1.connect(ctx.destination);
          
          osc1.type = 'sine';
          osc1.frequency.value = 523.25;
          gain1.gain.setValueAtTime(0, now);
          gain1.gain.linearRampToValueAtTime(0.3, now + 0.01);
          gain1.gain.linearRampToValueAtTime(0, now + 0.15);
          
          osc1.start(now);
          osc1.stop(now + 0.15);
          
          // Second tone: E (659.25 Hz) - slightly delayed
          const osc2 = ctx.createOscillator();
          const gain2 = ctx.createGain();
          osc2.connect(gain2);
          gain2.connect(ctx.destination);
          
          osc2.type = 'sine';
          osc2.frequency.value = 659.25;
          gain2.gain.setValueAtTime(0, now + 0.1);
          gain2.gain.linearRampToValueAtTime(0.3, now + 0.11);
          gain2.gain.linearRampToValueAtTime(0, now + 0.3);
          
          osc2.start(now + 0.1);
          osc2.stop(now + 0.3);
        },
        
        playErrorTone: function() {
          if (!this.audioContext) return;
          
          const ctx = this.audioContext;
          const now = ctx.currentTime;
          
          // Create alarming error sound: three buzzer-like pulses
          for (let i = 0; i < 3; i++) {
            const startTime = now + (i * 0.25);
            
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            
            osc.type = 'sawtooth'; // Harsher sound for error
            osc.frequency.value = 200; // Low frequency for alert
            
            gain.gain.setValueAtTime(0, startTime);
            gain.gain.linearRampToValueAtTime(0.2, startTime + 0.01);
            gain.gain.linearRampToValueAtTime(0, startTime + 0.15);
            
            osc.start(startTime);
            osc.stop(startTime + 0.15);
          }
        }
      };
      
      // Initialize audio system
      AudioSystem.init();
      
      // Make it globally available
      window.AudioSystem = AudioSystem;
    })();
    
    // Custom Dropdown Logic for Offline Support
    (function() {
      function initDropdown() {
        const dropdown = document.getElementById('customerDropdown');
        const button = document.getElementById('customerDropdownButton');
        const menu = document.getElementById('customerDropdownMenu');
        const selectedText = document.getElementById('customerDropdownSelected');
        const hiddenInput = document.getElementById('customerSelect');
        
        if (!dropdown || !button || !menu || !selectedText || !hiddenInput) {
          console.error('Dropdown elements not found, retrying...');
          return false;
        }
        
        const options = menu.querySelectorAll('.custom-dropdown-option');
        
        if (options.length === 0) {
          console.error('Dropdown options not found, retrying...');
          return false;
        }
        
        console.log('Initializing dropdown with', options.length, 'options');
        
        // Toggle dropdown
        button.addEventListener('click', function(e) {
          e.stopPropagation();
          dropdown.classList.toggle('open');
          console.log('Dropdown toggled, open:', dropdown.classList.contains('open'));
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function() {
          dropdown.classList.remove('open');
        });
        
        // Prevent closing when clicking inside menu
        menu.addEventListener('click', function(e) {
          e.stopPropagation();
        });
        
        // Handle option selection
        options.forEach(function(option) {
          option.addEventListener('click', function() {
            const value = this.getAttribute('data-value');
            const text = this.textContent;
            
            console.log('Option clicked:', value, text);
            
            // Update selected text
            selectedText.textContent = text;
            
            // Update hidden input
            hiddenInput.value = value;
            
            // Update selected class
            options.forEach(function(opt) {
              opt.classList.remove('selected');
            });
            this.classList.add('selected');
            
            // Close dropdown
            dropdown.classList.remove('open');
            
            // Trigger change event for compatibility with existing code
            const event = new Event('change', { bubbles: true });
            hiddenInput.dispatchEvent(event);
            
            // Save to form data (matching existing functionality)
            if (typeof saveFormData === 'function') {
              const customerQR = document.getElementById('customerQR');
              const ourQR = document.getElementById('ourQR');
              saveFormData({
                customerQR: customerQR ? customerQR.value : '',
                ourQR: ourQR ? ourQR.value : '',
                customerType: value
              });
            }
            
            console.log('Customer type changed to:', value);
          });
        });
        
        console.log('Dropdown initialized successfully');
        return true;
      }
      
      // Try to initialize immediately if DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
          console.log('DOM loaded, initializing dropdown...');
          if (!initDropdown()) {
            // Retry after a short delay if initialization failed
            setTimeout(initDropdown, 100);
          }
        });
      } else {
        // DOM already loaded
        console.log('DOM already loaded, initializing dropdown...');
        if (!initDropdown()) {
          // Retry after a short delay if initialization failed
          setTimeout(initDropdown, 100);
        }
      }
      
      // Restore saved customer type on page load
      window.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
          const hiddenInput = document.getElementById('customerSelect');
          const menu = document.getElementById('customerDropdownMenu');
          
          if (!hiddenInput || !menu) {
            console.log('Cannot restore customer type - elements not found');
            return;
          }
          
          if (typeof loadFormData === 'function') {
            const savedFormData = loadFormData();
            if (savedFormData.customerType) {
              console.log('Restoring saved customer type:', savedFormData.customerType);
              const savedOption = menu.querySelector('[data-value="' + savedFormData.customerType + '"]');
              if (savedOption) {
                savedOption.click();
              }
            }
          }
        }, 200);
      });
    })();
    
    // Offline Mode Handler
    (function() {
      // Manual offline mode override - stored in localStorage
      let manualOfflineMode = localStorage.getItem('manualOfflineMode') === 'true';
      
      function isOfflineMode() {
        // If manual offline mode is enabled, always return false for isOnline
        if (manualOfflineMode) {
          return true;
        }
        return !navigator.onLine;
      }
      
      function updateOfflineUI() {
        const offline = isOfflineMode();
        const isOnline = !offline;
        
        // Get elements fresh each time to ensure they exist
        const learningModeBtn = document.getElementById('learningModeBtn');
        const onlineStatus = document.getElementById('onlineStatus');
        const onlineStatusText = document.getElementById('onlineStatusText');
        const toggleBtn = document.getElementById('toggleOfflineBtn');
        
        // Update learning mode button
        if (learningModeBtn) {
          if (isOnline) {
            learningModeBtn.disabled = false;
            learningModeBtn.style.opacity = '1';
            learningModeBtn.style.cursor = 'pointer';
            learningModeBtn.title = '';
          } else {
            learningModeBtn.disabled = true;
            learningModeBtn.style.opacity = '0.5';
            learningModeBtn.style.cursor = 'not-allowed';
            learningModeBtn.title = '„Ç™„Éï„É©„Ç§„É≥„Åß„ÅØ‰ΩøÁî®„Åß„Åç„Åæ„Åõ„Çì';
          }
        }
        
        // Update online/offline status indicator
        if (onlineStatus && onlineStatusText) {
          if (isOnline) {
            onlineStatus.style.backgroundColor = '#d1fae5';
            onlineStatus.style.color = '#065f46';
            onlineStatusText.textContent = manualOfflineMode ? 
              'üü¢ „Ç™„É≥„É©„Ç§„É≥ (ÊâãÂãï„Ç™„Éï„É©„Ç§„É≥„É¢„Éº„ÉâËß£Èô§)' : 
              'üü¢ „Ç™„É≥„É©„Ç§„É≥ („Éá„Éº„Çø„Éô„Éº„ÇπÂêåÊúü‰∏≠)';
          } else {
            onlineStatus.style.backgroundColor = '#fee2e2';
            onlineStatus.style.color = '#991b1b';
            onlineStatusText.textContent = manualOfflineMode ? 
              'üî¥ ÊâãÂãï„Ç™„Éï„É©„Ç§„É≥„É¢„Éº„Éâ („É≠„Éº„Ç´„É´„ÅÆ„Åø)' :
              'üî¥ „Ç™„Éï„É©„Ç§„É≥ („É≠„Éº„Ç´„É´„É¢„Éº„Éâ - „Éá„Éº„Çø„ÅØÂæå„ÅßÂêåÊúü„Åï„Çå„Åæ„Åô)';
          }
        }
        
        // Update toggle button style
        if (toggleBtn) {
          if (manualOfflineMode) {
            toggleBtn.style.backgroundColor = '#22c55e';
            toggleBtn.style.color = 'white';
            toggleBtn.textContent = '„Ç™„É≥„É©„Ç§„É≥„Å´Êàª„Åô';
          } else {
            toggleBtn.style.backgroundColor = '#6b7280';
            toggleBtn.style.color = 'white';
            toggleBtn.textContent = '„Ç™„Éï„É©„Ç§„É≥„É¢„Éº„Éâ';
          }
        }
        
        console.log('Offline UI updated - Manual offline:', manualOfflineMode, 'Navigator online:', navigator.onLine, 'Effective offline:', offline);
        
        // Update the global isOnline variable in labelComparator.js if it exists
        if (typeof window.updateOnlineStatus === 'function') {
          window.updateOnlineStatus(isOnline);
        }
      }
      
      // Toggle offline mode manually
      window.toggleOfflineMode = function() {
        manualOfflineMode = !manualOfflineMode;
        localStorage.setItem('manualOfflineMode', manualOfflineMode.toString());
        console.log('Manual offline mode toggled:', manualOfflineMode);
        
        // Update UI immediately
        updateOfflineUI();
        
        // Trigger custom event for labelComparator.js to react
        window.dispatchEvent(new CustomEvent('manualOfflineModeChanged', { 
          detail: { isOnline: !manualOfflineMode } 
        }));
      };
      
      // Update UI when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', updateOfflineUI);
      } else {
        // DOM already loaded, update immediately
        updateOfflineUI();
      }
      
      // Update UI when online/offline status changes
      window.addEventListener('online', updateOfflineUI);
      window.addEventListener('offline', updateOfflineUI);
      
      // Override openLearningMode function
      window.openLearningMode = function() {
        if (isOfflineMode()) {
          alert('Â≠¶Áøí„É¢„Éº„Éâ„ÅØ„Ç™„É≥„É©„Ç§„É≥ÊôÇ„ÅÆ„Åø‰ΩøÁî®„Åß„Åç„Åæ„Åô„ÄÇ');
          return;
        }
        window.location.href = 'qrLearning.html';
      };
    })();
  </script>

  <script>

    // IndexedDB Cache System for QR Learning Patterns
// This handles local storage of customer-specific QR patterns with hash validation

// Global configuration - Change server URL here
const QR_PATTERN_CONFIG = {
  serverURL: "https://kurachi.onrender.com"
  // Alternative: "http://localhost:3000"
};

class QRPatternCache {
  constructor() {
    this.dbName = 'QRPatternCacheDB';
    this.version = 1;
    this.db = null;
    this.initialized = false;
  }

  // Initialize IndexedDB
  async init() {
    if (this.initialized) return true;

    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = () => {
        console.error('IndexedDB initialization failed:', request.error);
        reject(request.error);
      };

      request.onsuccess = () => {
        this.db = request.result;
        this.initialized = true;
        console.log('IndexedDB initialized successfully');
        resolve(true);
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Create patterns store
        if (!db.objectStoreNames.contains('patterns')) {
          const patternsStore = db.createObjectStore('patterns', { keyPath: 'customerType' });
          patternsStore.createIndex('hash', 'hash', { unique: false });
          patternsStore.createIndex('lastUpdated', 'lastUpdated', { unique: false });
        }

        // Create hashes store for quick hash checking
        if (!db.objectStoreNames.contains('hashes')) {
          const hashesStore = db.createObjectStore('hashes', { keyPath: 'customerType' });
        }

        console.log('IndexedDB stores created');
      };
    });
  }

  // Get stored pattern for a customer
  async getPattern(customerType) {
    if (!this.initialized) await this.init();

    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['patterns'], 'readonly');
      const store = transaction.objectStore('patterns');
      const request = store.get(customerType);

      request.onsuccess = () => {
        const result = request.result;
        if (result) {
          console.log(`Retrieved pattern for ${customerType}:`, result);
          resolve(result);
        } else {
          console.log(`No pattern found for ${customerType}`);
          resolve(null);
        }
      };

      request.onerror = () => {
        console.error(`Error retrieving pattern for ${customerType}:`, request.error);
        reject(request.error);
      };
    });
  }

  // Store pattern for a customer
  async storePattern(customerType, patternData) {
    if (!this.initialized) await this.init();

    const patternRecord = {
      customerType: customerType,
      hash: patternData.hash,
      patterns: patternData.patterns,
      extractionRules: patternData.extractionRules,
      detectionRules: patternData.detectionRules,
      metadata: patternData.metadata,
      lastUpdated: new Date().toISOString()
    };

    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['patterns', 'hashes'], 'readwrite');
      
      // Store pattern
      const patternsStore = transaction.objectStore('patterns');
      const patternsRequest = patternsStore.put(patternRecord);

      // Store hash for quick checking
      const hashesStore = transaction.objectStore('hashes');
      const hashRecord = {
        customerType: customerType,
        hash: patternData.hash,
        lastUpdated: patternRecord.lastUpdated
      };
      const hashesRequest = hashesStore.put(hashRecord);

      transaction.oncomplete = () => {
        console.log(`Pattern stored successfully for ${customerType}`);
        resolve(true);
      };

      transaction.onerror = () => {
        console.error(`Error storing pattern for ${customerType}:`, transaction.error);
        reject(transaction.error);
      };
    });
  }

  // Get stored hash for a customer (for quick comparison)
  async getStoredHash(customerType) {
    if (!this.initialized) await this.init();

    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['hashes'], 'readonly');
      const store = transaction.objectStore('hashes');
      const request = store.get(customerType);

      request.onsuccess = () => {
        const result = request.result;
        if (result) {
          resolve(result.hash);
        } else {
          resolve(null);
        }
      };

      request.onerror = () => {
        console.error(`Error retrieving hash for ${customerType}:`, request.error);
        reject(request.error);
      };
    });
  }

  // Delete pattern for a customer
  async deletePattern(customerType) {
    if (!this.initialized) await this.init();

    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['patterns', 'hashes'], 'readwrite');
      
      const patternsStore = transaction.objectStore('patterns');
      const hashesStore = transaction.objectStore('hashes');
      
      patternsStore.delete(customerType);
      hashesStore.delete(customerType);

      transaction.oncomplete = () => {
        console.log(`Pattern deleted for ${customerType}`);
        resolve(true);
      };

      transaction.onerror = () => {
        console.error(`Error deleting pattern for ${customerType}:`, transaction.error);
        reject(transaction.error);
      };
    });
  }

  // Clear all patterns
  async clearAllPatterns() {
    if (!this.initialized) await this.init();

    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['patterns', 'hashes'], 'readwrite');
      
      const patternsStore = transaction.objectStore('patterns');
      const hashesStore = transaction.objectStore('hashes');
      
      patternsStore.clear();
      hashesStore.clear();

      transaction.oncomplete = () => {
        console.log('All patterns cleared');
        resolve(true);
      };

      transaction.onerror = () => {
        console.error('Error clearing patterns:', transaction.error);
        reject(transaction.error);
      };
    });
  }

  // Get all stored customer types
  async getAllCustomerTypes() {
    if (!this.initialized) await this.init();

    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['patterns'], 'readonly');
      const store = transaction.objectStore('patterns');
      const request = store.getAllKeys();

      request.onsuccess = () => {
        resolve(request.result);
      };

      request.onerror = () => {
        console.error('Error retrieving customer types:', request.error);
        reject(request.error);
      };
    });
  }

  // Check if pattern needs update by comparing hashes
  async needsUpdate(customerType, serverHash) {
    try {
      const storedHash = await this.getStoredHash(customerType);
      const needsUpdate = !storedHash || storedHash !== serverHash;
      
      console.log(`Hash check for ${customerType}: stored=${storedHash}, server=${serverHash}, needsUpdate=${needsUpdate}`);
      return needsUpdate;
    } catch (error) {
      console.error('Error checking hash:', error);
      return true; // If error, assume update is needed
    }
  }
}

// QR Pattern Sync System
class QRPatternSync {
  constructor(serverURL) {
    this.serverURL = serverURL;
    this.cache = new QRPatternCache();
    this.isOnline = navigator.onLine;
    
    // Monitor network status
    window.addEventListener('online', () => {
      this.isOnline = true;
      console.log('Network connection restored');
    });
    
    window.addEventListener('offline', () => {
      this.isOnline = false;
      console.log('Network connection lost');
    });
  }

  // Initialize the sync system
  async init() {
    await this.cache.init();
    console.log('QR Pattern Sync system initialized');
  }

  // Check and update patterns for a specific customer
  async syncCustomerPattern(customerType) {
    if (!this.isOnline) {
      console.log('Offline - using cached patterns only');
      return await this.cache.getPattern(customerType);
    }

    try {
      // Get server hash for comparison
      const response = await fetch(`${this.serverURL}/qr-patterns/hash/${customerType}`);
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}`);
      }

      const { hash: serverHash } = await response.json();
      
      // Check if update is needed
      const needsUpdate = await this.cache.needsUpdate(customerType, serverHash);
      
      if (needsUpdate) {
        console.log(`Updating patterns for ${customerType}`);
        
        // Fetch new patterns from server
        const patternsResponse = await fetch(`${this.serverURL}/qr-patterns/${customerType}`);
        if (!patternsResponse.ok) {
          throw new Error(`Failed to fetch patterns: ${patternsResponse.status}`);
        }

        const patternData = await patternsResponse.json();
        
        // Store in cache
        await this.cache.storePattern(customerType, patternData);
        
        console.log(`Patterns updated for ${customerType}`);
        return patternData;
      } else {
        console.log(`Patterns are up to date for ${customerType}`);
        return await this.cache.getPattern(customerType);
      }
    } catch (error) {
      console.error(`Error syncing patterns for ${customerType}:`, error);
      
      // Fallback to cached version
      console.log('Falling back to cached patterns');
      return await this.cache.getPattern(customerType);
    }
  }

  // Get pattern for customer (with automatic sync)
  async getCustomerPattern(customerType) {
    return await this.syncCustomerPattern(customerType);
  }

  // Delete customer pattern from cache
  async deleteCustomerPattern(customerType) {
    return await this.cache.deletePattern(customerType);
  }

  // Clear all cached patterns
  async clearAllPatterns() {
    return await this.cache.clearAllPatterns();
  }

  // Force refresh all patterns from server
  async forceRefreshAll() {
    if (!this.isOnline) {
      throw new Error('Cannot refresh patterns while offline');
    }

    try {
      const customerTypes = await this.cache.getAllCustomerTypes();
      const refreshPromises = customerTypes.map(customerType => {
        // Force update by clearing hash first
        return this.cache.deletePattern(customerType)
          .then(() => this.syncCustomerPattern(customerType));
      });

      await Promise.all(refreshPromises);
      console.log('All patterns refreshed from server');
    } catch (error) {
      console.error('Error refreshing patterns:', error);
      throw error;
    }
  }
}

// Global instance
let qrPatternSync = null;

// Set global server URL
function setQRPatternServerURL(url) {
  QR_PATTERN_CONFIG.serverURL = url;
  console.log(`QR Pattern server URL updated to: ${url}`);
  
  // Reset the global instance to force re-initialization with new URL
  qrPatternSync = null;
}

// Get current server URL
function getQRPatternServerURL() {
  return QR_PATTERN_CONFIG.serverURL;
}

// Initialize the system
async function initQRPatternSystem(serverURL = null) {
  const finalServerURL = serverURL || QR_PATTERN_CONFIG.serverURL;
  
  if (!qrPatternSync) {
    qrPatternSync = new QRPatternSync(finalServerURL);
    await qrPatternSync.init();
    console.log(`QR Pattern System initialized with server: ${finalServerURL}`);
  }
  return qrPatternSync;
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { 
    QRPatternCache, 
    QRPatternSync, 
    initQRPatternSystem,
    setQRPatternServerURL,
    getQRPatternServerURL,
    QR_PATTERN_CONFIG
  };
}
  </script>
  
  <script>
// Use the serverURL from QR_PATTERN_CONFIG
const serverURL = QR_PATTERN_CONFIG.serverURL;

// Enable debug mode for troubleshooting
const DEBUG_MODE = true;

// Debug logging function that only logs when debug mode is enabled
function debug(...args) {
  if (DEBUG_MODE) {
    console.debug(...args);
  }
}

// Cache for DOM elements
const domCache = {};

// Local storage keys
const STORAGE_KEYS = {
  PENDING_LOGS: 'labelComparator_pendingLogs',
  SCAN_LOG: 'labelComparator_scanLog',
  FORM_DATA: 'labelComparator_formData'
};

// Queue for pending database insertions
let pendingLogs = [];
let isOnline = navigator.onLine;

// Load pending logs from localStorage on startup
function loadPendingLogs() {
  const stored = localStorage.getItem(STORAGE_KEYS.PENDING_LOGS);
  if (stored) {
    try {
      pendingLogs = JSON.parse(stored);
    } catch (e) {
      console.error('Error loading pending logs:', e);
      pendingLogs = [];
    }
  }
}

// Save pending logs to localStorage
function savePendingLogs() {
  localStorage.setItem(STORAGE_KEYS.PENDING_LOGS, JSON.stringify(pendingLogs));
}

// Load scan log from localStorage
function loadScanLog() {
  const stored = localStorage.getItem(STORAGE_KEYS.SCAN_LOG);
  if (stored) {
    try {
      return JSON.parse(stored);
    } catch (e) {
      console.error('Error loading scan log:', e);
      return [];
    }
  }
  return [];
}

// Optimized localStorage operations with debouncing
let saveOperationsTimer = null;
const pendingSaves = new Map();

// Non-blocking localStorage operations
function debouncedStorageSave(key, data, delay = 100) {
  pendingSaves.set(key, data);
  
  if (saveOperationsTimer) {
    clearTimeout(saveOperationsTimer);
  }
  
  saveOperationsTimer = setTimeout(() => {
    // Process all pending saves at once
    pendingSaves.forEach((value, storageKey) => {
      try {
        localStorage.setItem(storageKey, JSON.stringify(value));
      } catch (e) {
        console.error(`Error saving to localStorage (${storageKey}):`, e);
      }
    });
    pendingSaves.clear();
  }, delay);
}

// Save scan log to localStorage - non-blocking
function saveScanLog(logs) {
  debouncedStorageSave(STORAGE_KEYS.SCAN_LOG, logs);
}

// Load form data from localStorage - with cache
let cachedFormData = null;
function loadFormData() {
  if (cachedFormData) return cachedFormData;
  
  const stored = localStorage.getItem(STORAGE_KEYS.FORM_DATA);
  if (stored) {
    try {
      cachedFormData = JSON.parse(stored);
      return cachedFormData;
    } catch (e) {
      console.error('Error loading form data:', e);
      return {};
    }
  }
  return {};
}

// Save form data to localStorage - non-blocking
function saveFormData(data) {
  cachedFormData = data; // Update cache
  debouncedStorageSave(STORAGE_KEYS.FORM_DATA, data);
}

// Insert log to database using /queries route with timeout
async function insertLogToDatabase(logData) {
  // Use AbortController for fetch timeout
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
  
  try {
    console.time('mongodb-insert');
    const startTime = performance.now();
    
    const response = await fetch(`${serverURL}/queries`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        dbName: "submittedDB",
        collectionName: "labelComparatorLogDB",
        insertData: [logData]
      }),
      signal: controller.signal
    });

    const result = await response.json();
    const duration = performance.now() - startTime;
    
    if (response.ok && result.insertedCount > 0) {
      console.log(`Log successfully inserted to database in ${duration.toFixed(0)}ms`);
      return true;
    } else {
      console.error(`Failed to insert log in ${duration.toFixed(0)}ms:`, result);
      return false;
    }
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Database insertion timed out after 10s');
    } else {
      console.error('Error inserting log to database:', error);
    }
    return false;
  } finally {
    clearTimeout(timeoutId);
    console.timeEnd('mongodb-insert');
  }
}

// Process pending logs in the background with rate limiting
async function processPendingLogsBackground() {
  if (!isOnline || pendingLogs.length === 0) {
    uploadQueueProcessing = false;
    return;
  }

  console.log(`Processing ${pendingLogs.length} pending logs in background...`);
  
  // Record start time for rate limiting
  lastUploadTime = Date.now();
  
  // Sort by timestamp to maintain order
  pendingLogs.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
  
  // Only process a small batch at a time to prevent long-running tasks
  // This way, if user starts scanning again, we won't block the main thread
  const MAX_BATCH_SIZE = 5;
  const currentBatch = pendingLogs.slice(0, MAX_BATCH_SIZE);
  const remainingLogs = pendingLogs.slice(MAX_BATCH_SIZE);
  const failedLogs = [];

  try {
    // Process current batch
    for (const log of currentBatch) {
      try {
        const success = await insertLogToDatabase(log);
        if (!success) {
          failedLogs.push(log);
        }
      } catch (error) {
        console.error('Error uploading log:', error);
        failedLogs.push(log);
      }
    }
    
    // Update pending logs with failed ones from this batch plus remaining ones
    pendingLogs = [...failedLogs, ...remainingLogs];
    savePendingLogs();
    
    // Report status
    if (failedLogs.length === 0) {
      console.log(`Successfully processed ${currentBatch.length} logs`);
    } else {
      console.log(`${failedLogs.length}/${currentBatch.length} logs failed to process`);
    }
  } catch (error) {
    console.error('Error in background processing:', error);
  } finally {
    // If we still have logs to process, schedule another batch
    if (pendingLogs.length > 0) {
      // Wait a bit before processing next batch to prevent overloading
      setTimeout(() => {
        processPendingLogsBackground();
      }, MIN_UPLOAD_INTERVAL);
    } else {
      uploadQueueProcessing = false;
      console.log('All logs processed');
    }
  }
}

// Legacy function for manual triggering
async function processPendingLogs() {
  if (uploadQueueProcessing) {
    console.log("Upload already in progress");
    return;
  }
  
  scheduleBackgroundUpload();
}

// Background upload queue management
let uploadQueueProcessing = false;
let lastUploadTime = 0;
const MIN_UPLOAD_INTERVAL = 2000; // At least 2 seconds between upload batches

// Add log entry (always saves locally first, then queues for background upload)
function addLogEntry(customerProduct, ourProduct, isMatch, customerQR, ourQR) {
  const timestamp = new Date().toISOString();
  const customerType = domCache['customerSelect'] ? domCache['customerSelect'].value : 'tn';
  
  const logData = {
    timestamp: timestamp,
    customer_type: customerType,
    ÂìÅÁï™_customer: customerProduct,
    ÂìÅÁï™_our: ourProduct,
    comparison_result: isMatch ? '‰∏ÄËá¥' : '‰∏ç‰∏ÄËá¥',
    customer_qr: customerQR,
    our_qr: ourQR,
    is_match: isMatch,
    created_at: timestamp
  };

  // Always add to pending logs first (treat as offline by default)
  pendingLogs.push(logData);
  savePendingLogs();
  
  // Schedule background processing if online - with rate limiting
  if (isOnline && !uploadQueueProcessing) {
    const now = Date.now();
    const timeSinceLastUpload = now - lastUploadTime;
    
    // If we haven't uploaded recently, process the queue
    if (timeSinceLastUpload > MIN_UPLOAD_INTERVAL) {
      scheduleBackgroundUpload();
    }
  }
}

// Schedule background upload with low priority
function scheduleBackgroundUpload() {
  if (uploadQueueProcessing) return; // Already processing
  uploadQueueProcessing = true;
  
  // Use setTimeout with zero delay to push to end of event queue
  // This ensures UI operations complete first
  setTimeout(() => {
    processPendingLogsBackground();
  }, 0);
}

// Function to update online status (can be called externally)
window.updateOnlineStatus = function(online) {
  isOnline = online;
  console.log('Online status updated to:', isOnline);
  
  if (isOnline && pendingLogs.length > 0 && !uploadQueueProcessing) {
    console.log(`Scheduling upload of ${pendingLogs.length} pending logs`);
    setTimeout(() => {
      scheduleBackgroundUpload();
    }, 1000);
  } else if (!isOnline) {
    uploadQueueProcessing = false;
  }
};

// Monitor network status
window.addEventListener('online', () => {
  isOnline = true;
  console.log('Network connection restored');
  
  // Schedule background upload with a slight delay to ensure connection is stable
  setTimeout(() => {
    if (pendingLogs.length > 0 && !uploadQueueProcessing) {
      console.log(`Scheduling upload of ${pendingLogs.length} pending logs after reconnection`);
      scheduleBackgroundUpload();
    }
  }, 1000);
});

window.addEventListener('offline', () => {
  isOnline = false;
  console.log('Network connection lost');
  
  // Set flag to false since uploads can't continue
  uploadQueueProcessing = false;
});

// Listen for manual offline mode changes from the UI
window.addEventListener('manualOfflineModeChanged', (event) => {
  isOnline = event.detail.isOnline;
  console.log('Manual offline mode changed, isOnline now:', isOnline);
  
  if (isOnline && pendingLogs.length > 0 && !uploadQueueProcessing) {
    console.log(`Resuming uploads after manual mode change`);
    setTimeout(() => {
      scheduleBackgroundUpload();
    }, 500);
  } else if (!isOnline) {
    uploadQueueProcessing = false;
  }
});

  // Pre-initialize DOM elements
document.addEventListener("DOMContentLoaded", () => {
  console.time('initialization');
  
  // Cache frequently used DOM elements
  ['logList', 'scanStatus', 'alert-sound', 'success-sound', 'welcomeModal', 'startButton', 
   'customerQR', 'ourQR', 'result', 'mismatchModal', 'customerSelect'].forEach(id => {
    domCache[id] = document.getElementById(id);
  });  // Reference cached elements - make sure they exist
  const logList = domCache['logList'];
  const welcomeModal = domCache['welcomeModal'];
  const startButton = domCache['startButton'];
  
  // Show welcome modal on page load (immediately)
  welcomeModal.style.display = 'flex';
  
  // Prepare audio elements for faster response
  if (domCache['alert-sound']) {
    domCache['alert-sound'].load();
  }
  if (domCache['success-sound']) {
    domCache['success-sound'].load();
  }
  
  // Handle customer selection change
  const customerSelect = domCache['customerSelect'];
  if (customerSelect) {
    customerSelect.addEventListener('change', () => {
      const formData = {
        customerQR: domCache['customerQR'] ? domCache['customerQR'].value : '',
        ourQR: domCache['ourQR'] ? domCache['ourQR'].value : '',
        customerType: customerSelect.value
      };
      saveFormData(formData);
      console.log('Customer type changed to:', customerSelect.value);
    });
  }

  // Handle start button click - optimized
  startButton.addEventListener('click', () => {
    console.time('start-button');
    
    // Hide welcome modal immediately
    welcomeModal.style.display = 'none';
    
    // Initialize audio with user interaction
    if (domCache['alert-sound']) {
      // Play a silent sound to initialize audio
      const audio = domCache['alert-sound'];
      audio.muted = true;
      audio.volume = 0;
      
      // Pre-load the sound
      audio.load();
      
      // Try to play it silently to initialize audio context
      audio.play().then(() => {
        console.log("Alert audio successfully initialized");
      }).catch(error => {
        console.error("Alert audio initialization error:", error);
      });
    }
    
    // Initialize success sound with user interaction
    if (domCache['success-sound']) {
      const successAudio = domCache['success-sound'];
      successAudio.muted = true;
      successAudio.volume = 0;
      
      // Pre-load the success sound
      successAudio.load();
      
      // Try to play it silently to initialize audio context
      successAudio.play().then(() => {
        console.log("Success audio successfully initialized");
      }).catch(error => {
        console.error("Success audio initialization error:", error);
      });
    }
    
    // Focus on scanning area
    document.body.focus();
    console.timeEnd('start-button');
  });
  
  // Initialize QR Pattern System
  setTimeout(async () => {
    try {
      await initQRPatternSystem(serverURL); // Pass the serverURL from labelComparator.js
      console.log('QR Pattern System initialized successfully');
      
      // Sync patterns for all customers on startup
      const customers = ['tn', 'toyota', 'kinuura'];
      for (const customer of customers) {
        try {
          await qrPatternSync.syncCustomerPattern(customer);
        } catch (error) {
          console.warn(`Failed to sync patterns for ${customer}:`, error);
        }
      }
    } catch (error) {
      console.error('Failed to initialize QR Pattern System:', error);
    }
  }, 500);

  // Non-critical initialization - defer to not block UI
  setTimeout(() => {
    // Load pending logs (background operation)
    loadPendingLogs();
    
    // Restore form data if exists
    const savedFormData = loadFormData();
    if (savedFormData.customerQR && domCache['customerQR']) {
      domCache['customerQR'].value = savedFormData.customerQR;
    }
    if (savedFormData.ourQR && domCache['ourQR']) {
      domCache['ourQR'].value = savedFormData.ourQR;
    }
    if (savedFormData.customerType && domCache['customerSelect']) {
      domCache['customerSelect'].value = savedFormData.customerType;
    }
    
    // Restore scan log in batches to prevent UI blocking
    const savedLogs = loadScanLog();
    
    if (savedLogs.length > 0) {
      // Create fragment for batch DOM update (more efficient)
      const fragment = document.createDocumentFragment();
      
      // Process logs in batches
      const processBatch = (startIdx, batchSize) => {
        const endIdx = Math.min(startIdx + batchSize, savedLogs.length);
        
        for (let i = startIdx; i < endIdx; i++) {
          const li = document.createElement("li");
          li.innerHTML = savedLogs[i];
          fragment.appendChild(li);
        }
        
        // If more batches remain, schedule next batch
        if (endIdx < savedLogs.length) {
          setTimeout(() => processBatch(endIdx, batchSize), 0);
        } else {
          // Final batch - append to DOM
          logList.appendChild(fragment);
        }
      };
      
      // Start batch processing (10 items per batch)
      processBatch(0, 10);
    }
    
    // Process any pending logs if online - low priority
    if (isOnline) {
      setTimeout(() => {
        processPendingLogs();
      }, 1000);
    }
    
    console.timeEnd('initialization');
  }, 0);
  
  // State for bluetooth scanner input
  let scanBuffer = "";
  let scanTimeout;
  const SCAN_TIMEOUT = 150; // ms - increased for better reliability with customer QR codes

  // Customer product extraction using learned patterns from cache
  async function extractCustomerProduct(qr) {
    console.log('Extracting customer product from:', qr);
    
    // If empty input, return null
    if (!qr) {
      console.log('Empty QR input');
      return null;
    }
    
    // Get selected customer type
    const customerType = domCache['customerSelect'] ? domCache['customerSelect'].value : 'tn';
    console.log('Selected customer type:', customerType);
    
    try {
      // Try to use learned patterns first
      if (qrPatternSync) {
        const pattern = await qrPatternSync.getCustomerPattern(customerType);
        if (pattern && pattern.extractionRules) {
          console.log('Using learned pattern for extraction');
          return extractWithLearnedPattern(qr, pattern.extractionRules);
        }
      }
      
      // Fallback to hardcoded logic for backward compatibility
      console.log('Falling back to hardcoded extraction logic');
      switch (customerType) {
        case 'tn':
          return extractTNProduct(qr);
        case 'toyota':
          return extractToyotaProduct(qr);
        case 'kinuura':
          return extractKinuuraProduct(qr);
        default:
          console.error('Unknown customer type:', customerType);
          return null;
      }
    } catch (e) {
      console.error('Error extracting customer product:', e);
      return null;
    }
  }

  // Extract product using learned patterns
  function extractWithLearnedPattern(qr, extractionRules) {
    console.log('Applying learned extraction rules:', extractionRules);
    
    for (const rule of extractionRules) {
      try {
        if (rule.type === 'regex') {
          const match = qr.match(new RegExp(rule.pattern));
          if (match && match[rule.captureGroup || 1]) {
            let result = match[rule.captureGroup || 1];
            
            // Apply formatting rules if specified
            if (rule.formatting) {
              result = applyFormatting(result, rule.formatting);
            }
            
            console.log('Extracted using regex rule:', result);
            return result;
          }
        } else if (rule.type === 'position') {
          // Position-based extraction
          const parts = qr.split(new RegExp(rule.delimiter || '\\s+'));
          if (parts.length > rule.partIndex && parts[rule.partIndex]) {
            let part = parts[rule.partIndex];
            
            if (rule.substring) {
              part = part.substring(rule.substring.start, rule.substring.end);
            }
            
            if (rule.formatting) {
              part = applyFormatting(part, rule.formatting);
            }
            
            console.log('Extracted using position rule:', part);
            return part;
          }
        }
      } catch (error) {
        console.error('Error applying extraction rule:', error, rule);
      }
    }
    
    console.log('No learned pattern matched');
    return null;
  }

  // Apply formatting rules to extracted text
  function applyFormatting(text, formatting) {
    let result = text;
    
    if (formatting.insert) {
      // Insert characters at specific positions
      for (const insert of formatting.insert) {
        result = result.substring(0, insert.position) + 
                insert.character + 
                result.substring(insert.position);
      }
    }
    
    if (formatting.prefix) {
      result = formatting.prefix + result;
    }
    
    if (formatting.suffix) {
      result = result + formatting.suffix;
    }
    
    return result;
  }

  // „ÉÜ„Ç£„Éº„Ç®„ÉåË£Ω‰ΩúÊâÄ format extraction
  function extractTNProduct(qr) {
    console.log('Extracting TN product from:', qr);
    
    // Specific customer format parsing:
    // Example: "2149657    460502B5B2C    0019GN5200253000202510010000150"
    
    // Step 1: Split by spaces to get the parts
    const parts = qr.trim().split(/\s+/);
    console.log(`Split QR into ${parts.length} parts:`, parts);
    
    // Step 2: Look for the part that starts with "0019"
    let raw = null;
    
    // First try the expected format: three parts with third part starting with "0019"
    if (parts.length === 3 && parts[2].startsWith('0019')) {
      console.log('Found standard 3-part format with 0019 in third part');
      raw = parts[2];
    } else {
      // If we don't have exactly 3 parts, look for any part that contains "0019"
      console.log('Searching for any part starting with 0019');
      for (let i = 0; i < parts.length; i++) {
        if (parts[i].startsWith('0019')) {
          console.log(`Found 0019 in part ${i+1}`);
          raw = parts[i];
          break;
        }
      }
    }
    
    // Step 3: If we found a part with "0019", extract the product code
    if (raw) {
      console.log('Processing raw customer data:', raw);
      
      // Format: 0019GN5200253000202510010000150
      // We want to extract "GN520-02530" from position 4 (after "0019")
      if (raw.length >= 14) { // Make sure it's long enough
        // Extract the product code after "0019"
        const productRaw = raw.substring(4, 14);  // Get GN52002530
        console.log('Raw product string:', productRaw);
        
        // Format it as GN520-02530
        let result;
        if (productRaw.startsWith('GN')) {
          // If it already starts with GN, use proper formatting
          const codeAfterGN = productRaw.substring(2);
          result = 'GN' + codeAfterGN.substring(0, 3) + '-' + codeAfterGN.substring(3, 8);
        } else {
          // Otherwise assume it's directly the product code
          result = productRaw.substring(0, 5) + '-' + productRaw.substring(5, 10);
        }
        
        console.log('Successfully extracted TN product:', result);
        return result;
      }
    }
    
    // If the standard format didn't work, try looking for GN anywhere in the string
    console.log('Trying alternative extraction method...');
    const gnMatch = qr.match(/GN([0-9]{3}[\-\/]?[0-9]{5})/);
    if (gnMatch && gnMatch[1]) {
      const formattedCode = 'GN' + gnMatch[1].replace(/[\-\/]/, '-');
      console.log('Extracted TN product via regex:', formattedCode);
      return formattedCode;
    }
    
    console.log('Failed to extract TN product');
    return null;
  }

  // „Éà„É®„ÇøÁ¥°Áπî format extraction (placeholder - you'll need to provide the actual format)
  function extractToyotaProduct(qr) {
    console.log('Extracting Toyota product from:', qr);
    
    // TODO: Implement Toyota QR format extraction
    // For now, return null as placeholder
    console.log('Toyota QR format not implemented yet');
    return null;
  }

  // Ë°£Êµ¶ format extraction (placeholder - you'll need to provide the actual format)
  function extractKinuuraProduct(qr) {
    console.log('Extracting Kinuura product from:', qr);
    
    // TODO: Implement Kinuura QR format extraction
    // For now, return null as placeholder
    console.log('Kinuura QR format not implemented yet');
    return null;
  }

  function extractOurProduct(qr) {
    // Fast check before splitting
    const commaPos = qr.indexOf(',');
    if (commaPos === -1) return qr.trim();
    return qr.substring(0, commaPos).trim();
  }

  // QR type detection using learned patterns
  async function detectQRType(qrCode) {
    console.log(`QR Type detection for: ${qrCode}`);
    
    // Get selected customer type
    const customerType = domCache['customerSelect'] ? domCache['customerSelect'].value : 'tn';
    
    // First check if it's our company QR (internal QR)
    // Internal QR characteristics:
    // 1. Contains comma (product,quantity format)
    // 2. Has dashes in product code
    // 3. Relatively short (< 50 characters)
    // 4. Product code pattern: digits-alphanumeric-alphanumeric
    
    const hasComma = qrCode.includes(',');
    const hasDash = qrCode.includes('-') || qrCode.includes('/');
    const isShort = qrCode.length < 50;
    
    // Pattern for internal QR: NNNNN-AAAAAA-AA or GN###-##### format
    const internalPattern = /^[A-Z0-9]{4,6}[\-\/][A-Z0-9]{4,6}[\-\/]?[A-Z0-9]{0,4}/;
    
    if ((hasComma && hasDash) || (isShort && hasDash && internalPattern.test(qrCode))) {
      console.log('Detected internal QR by pattern');
      return 'our';
    }
    
    // Try to use learned patterns for customer QR detection
    if (qrPatternSync) {
      try {
        const pattern = await qrPatternSync.getCustomerPattern(customerType);
        if (pattern && pattern.detectionRules) {
          console.log('Using learned pattern for detection');
          const isCustomer = detectWithLearnedPattern(qrCode, pattern.detectionRules);
          if (isCustomer) {
            return 'customer';
          }
        }
      } catch (error) {
        console.error('Error using learned detection pattern:', error);
      }
    }
    
    // Fallback to hardcoded detection logic
    console.log('Falling back to hardcoded detection logic');
    switch (customerType) {
      case 'tn':
        return detectTNQR(qrCode);
      case 'toyota':
        return detectToyotaQR(qrCode);
      case 'kinuura':
        return detectKinuuraQR(qrCode);
      default:
        console.log('Unknown customer type:', customerType);
        return null;
    }
  }

  // Detect QR type using learned patterns
  function detectWithLearnedPattern(qrCode, detectionRules) {
    console.log('Applying learned detection rules:', detectionRules);
    
    for (const rule of detectionRules) {
      try {
        if (rule.type === 'regex') {
          const regex = new RegExp(rule.pattern);
          if (regex.test(qrCode)) {
            console.log('Matched detection rule:', rule);
            return true;
          }
        } else if (rule.type === 'contains') {
          if (qrCode.includes(rule.text)) {
            console.log('Matched contains rule:', rule.text);
            return true;
          }
        } else if (rule.type === 'length') {
          if (qrCode.length >= rule.min && qrCode.length <= rule.max) {
            console.log('Matched length rule:', rule);
            return true;
          }
        } else if (rule.type === 'structure') {
          const parts = qrCode.split(new RegExp(rule.delimiter || '\\s+'));
          if (parts.length === rule.partCount) {
            console.log('Matched structure rule:', rule);
            return true;
          }
        }
      } catch (error) {
        console.error('Error applying detection rule:', error, rule);
      }
    }
    
    return false;
  }

  // „ÉÜ„Ç£„Éº„Ç®„ÉåË£Ω‰ΩúÊâÄ QR detection
  function detectTNQR(qrCode) {
    // Check for customer QR with specific space-separated format (e.g., "2149657    460502B5B2C    0019GN5200253000202510010000150")
    const spaceParts = qrCode.split(/\s+/);
    if (spaceParts.length === 3) {
      console.log('Detected possible triple-part space-separated QR:', spaceParts);
      
      // Check if third part starts with the customer pattern
      if (spaceParts[2] && spaceParts[2].includes('0019GN')) {
        console.log('Confirmed TN customer QR with 0019GN pattern in third part');
        return 'customer';
      }
    }
    
    // If it's longer and more complex, it's likely a customer QR
    if (qrCode.length > 20 && /^[A-Z0-9\s]+$/.test(qrCode)) {
      console.log('Detected TN customer QR by length and character pattern');
      return 'customer';
    }
    
    return null;
  }

  // „Éà„É®„ÇøÁ¥°Áπî QR detection (placeholder)
  function detectToyotaQR(qrCode) {
    console.log('Toyota QR detection not implemented yet');
    // TODO: Implement Toyota QR detection logic
    return null;
  }

  // Ë°£Êµ¶ QR detection (placeholder)
  function detectKinuuraQR(qrCode) {
    console.log('Kinuura QR detection not implemented yet');
    // TODO: Implement Kinuura QR detection logic
    return null;
  }

  function updateScanStatus(message, type = 'info') {
    if (domCache['scanStatus']) {
      domCache['scanStatus'].textContent = message;
      domCache['scanStatus'].className = `text-center text-sm font-medium ${
        type === 'success' ? 'text-green-600' : 
        type === 'error' ? 'text-red-600' : 'text-blue-600'
      }`;
    }
  }

  // Performance timing debug variables
  let lastScanTime = 0;
  let processingStartTime = 0;
  let lastScannedValues = []; // Store last few scanned values for debugging
  
  async function processScannedQR(qrCode) {
    // Start timing measurement
    processingStartTime = performance.now();
    console.log(`Processing QR (length: ${qrCode.length}) - Time since last scan: ${processingStartTime - lastScanTime}ms`);
    
    // Use cached DOM elements for better performance
    const customerQRField = domCache['customerQR'];
    const ourQRField = domCache['ourQR'];
    
    if (!customerQRField || !ourQRField) {
      console.error("DOM elements not found in cache");
      return;
    }
    
    // Get selected customer type for special case detection
    const customerType = domCache['customerSelect'] ? domCache['customerSelect'].value : 'tn';
    
    // Special case: Quick detection for known customer patterns
    let isCustomerQR = false;
    if (customerType === 'tn' && qrCode.includes('0019GN')) {
      isCustomerQR = true;
    }
    // Add more special cases for other customers when their formats are known
    
    if (isCustomerQR) {
      console.log(`Detected ${customerType} customer QR by pattern match`);
      customerQRField.value = qrCode;
      updateScanStatus("‚úÖ „ÅäÂÆ¢ÊßòQR„Çí„Çπ„Ç≠„É£„É≥„Åó„Åæ„Åó„Åü", 'success');
      const endTime = performance.now();
      console.log(`Customer QR processed in ${endTime - processingStartTime}ms`);
      lastScanTime = endTime;
      
      // Save form data and check if comparison is possible
      const formData = {
        customerQR: customerQRField.value,
        ourQR: ourQRField.value,
        customerType: domCache['customerSelect'] ? domCache['customerSelect'].value : 'tn'
      };
      
      setTimeout(() => saveFormData(formData), 0);
      
      if (formData.ourQR) {
        compareQRs();
      }
      
      return;
    }
    
    // Standard detection
    const type = await detectQRType(qrCode);
    
    if (!type) {
      updateScanStatus("‚ùå ‰∏çÊòé„Å™QR„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Åß„Åô", 'error');
      const endTime = performance.now();
      console.log(`Unknown QR processed in ${endTime - processingStartTime}ms`);
      lastScanTime = endTime;
      return;
    }

    // Update the appropriate field
    if (type === 'customer') {
      customerQRField.value = qrCode;
      updateScanStatus("‚úÖ „ÅäÂÆ¢ÊßòQR„Çí„Çπ„Ç≠„É£„É≥„Åó„Åæ„Åó„Åü", 'success');
    } else {
      ourQRField.value = qrCode;
      updateScanStatus("‚úÖ Á§æÂÜÖQR„Çí„Çπ„Ç≠„É£„É≥„Åó„Åæ„Åó„Åü", 'success');
    }

      // Save form data (debounced by using local variables)
    const formData = {
      customerQR: customerQRField.value,
      ourQR: ourQRField.value,
      customerType: domCache['customerSelect'] ? domCache['customerSelect'].value : 'tn'
    };    // Defer non-critical operations
    setTimeout(() => {
      saveFormData(formData);
    }, 0);

    // Auto-compare if both fields are filled - without delay
    if (formData.customerQR && formData.ourQR) {
      compareQRs();
    }
    
    // Log timing
    const endTime = performance.now();
    console.log(`QR processed in ${endTime - processingStartTime}ms`);
    lastScanTime = endTime;
  }

  async function compareQRs() {
    const compareStartTime = performance.now();
    console.log("Starting QR comparison");
    
    // Use cached DOM elements
    const customerQR = domCache['customerQR'] ? domCache['customerQR'].value : '';
    const ourQR = domCache['ourQR'] ? domCache['ourQR'].value : '';
    const result = domCache['result'];
    
    if (!result) {
      console.error("Result DOM element not found in cache");
      return;
    }
    
    // Debug the input values
    console.debug('Customer QR for extraction:', customerQR);
    console.debug('Our QR for extraction:', ourQR);
    
    // Extract product codes (these functions are now optimized)
    const customerProduct = await extractCustomerProduct(customerQR);
    const ourProduct = extractOurProduct(ourQR);
    
    console.debug('Extracted customer product:', customerProduct);
    console.debug('Extracted our product:', ourProduct);
    console.log(`Extraction complete in ${performance.now() - compareStartTime}ms`);
    
    // Generate timestamp once for both UI and logging
    const timestamp = new Date().toLocaleString();

    if (!customerProduct || !ourProduct) {
      result.textContent = "‚ùå Ë£ΩÂìÅÁï™Âè∑„ÅÆÊäΩÂá∫„Å´Â§±Êïó„Åó„Åæ„Åó„Åü";
      result.className = "mt-6 text-center text-lg font-semibold text-red-600";
      console.log(`Comparison failed in ${performance.now() - compareStartTime}ms - extraction error`);
      return;
    }

    // Simple string comparison
    const isMatch = customerProduct === ourProduct;
    console.log(`Match result (${isMatch}) determined in ${performance.now() - compareStartTime}ms`);

    // Update UI based on match result
    if (isMatch) {
      // Show match result
      result.textContent = "‚úÖ ‰∏ÄËá¥: " + customerProduct;
      result.className = "mt-6 text-center text-lg font-semibold text-green-600";
      
      // Play success sound to indicate match
      playSuccessSound();
      
      // Clear input fields immediately to prepare for next scan
      // But keep the result message and success sound
      if (domCache['customerQR']) domCache['customerQR'].value = "";
      if (domCache['ourQR']) domCache['ourQR'].value = "";
      
      // Clear saved form data immediately
      saveFormData({
        customerQR: "",
        ourQR: ""
      });
      
      // After a brief delay, clear the result message too
      setTimeout(() => {
        if (domCache['result']) domCache['result'].textContent = "";
        updateScanStatus("Ê¨°„ÅÆ„Çπ„Ç≠„É£„É≥„ÇíÂæÖÊ©ü‰∏≠...");
      }, 1500);
      
    } else {
      result.textContent = `‚ùå ‰∏ç‰∏ÄËá¥ „ÅäÂÆ¢Êßò: ${customerProduct} Á§æÂÜÖ: ${ourProduct}`;
      result.className = "mt-6 text-center text-lg font-semibold text-red-600";
      
      // Play alert sound and show visual warning immediately
      playAlertSound();
      document.body.classList.add('flash-red');
      showMismatchModal(customerProduct, ourProduct);
    }

    // Prepare log entry HTML once and reuse
    const logHtml = `<span class="text-gray-500">[${timestamp}]</span> 
                     „ÅäÂÆ¢Êßò: <span class="font-medium">${customerProduct}</span>, 
                     Á§æÂÜÖ: <span class="font-medium">${ourProduct}</span>, 
                     <span class="${isMatch ? 'text-green-600' : 'text-red-600'} font-semibold">
                       ${isMatch ? '‰∏ÄËá¥' : '‰∏ç‰∏ÄËá¥'}
                     </span>`;
    
    // Update UI log immediately
    const li = document.createElement("li");
    li.innerHTML = logHtml;
    logList.prepend(li);
    
    // Defer ALL non-critical operations to after critical UI updates
    // Use requestIdleCallback if available for even lower priority, otherwise setTimeout
    const deferOperation = window.requestIdleCallback || 
      ((callback) => setTimeout(callback, 50)); // 50ms delay as fallback
    
    deferOperation(() => {
      console.time('background-logging');
      
      // Add log entry to database (completely background operation)
      addLogEntry(customerProduct, ourProduct, isMatch, customerQR, ourQR);
      
      // Save log to localStorage for persistence - with separate timing
      const localStorageStart = performance.now();
      const currentLogs = loadScanLog();
      currentLogs.unshift(logHtml);
      if (currentLogs.length > 50) currentLogs.splice(50);
      saveScanLog(currentLogs);
      
      console.log(`Local storage operations: ${performance.now() - localStorageStart}ms`);
      console.timeEnd('background-logging');
      console.log(`Total comparison process: ${performance.now() - compareStartTime}ms`);
    });
    
    console.log(`Comparison complete in ${performance.now() - compareStartTime}ms`);
  }
  
  // Play the alert sound - using cached element or fallback
  function playAlertSound() {
    // Use AudioSystem if available (handles online/offline automatically)
    if (window.AudioSystem) {
      window.AudioSystem.playError();
      return;
    }
    
    // Fallback to original method
    const alertSound = domCache['alert-sound'];
    if (alertSound) {
      // Unmute and play at full volume
      alertSound.muted = false;
      alertSound.volume = 0.3;
      alertSound.currentTime = 0; // Reset to start
      
      // Use promise with timeout to prevent hanging
      const playPromise = alertSound.play();
      if (playPromise) {
        playPromise.catch(error => {
          console.error("Failed to play alert sound:", error);
          // Try once more with user interaction already present
          setTimeout(() => alertSound.play().catch(e => console.error("Retry failed:", e)), 100);
        });
      }
    }
  }
  
  // Play the success sound when QR codes match
  function playSuccessSound() {
    // Use AudioSystem if available (handles online/offline automatically)
    if (window.AudioSystem) {
      window.AudioSystem.playSuccess();
      return;
    }
    
    // Fallback to original method
    const successSound = domCache['success-sound'];
    if (successSound) {
      // Unmute and play at full volume
      successSound.muted = false;
      successSound.volume = 1.0; // Increased to full volume to be more audible
      successSound.currentTime = 0; // Reset to start
      
      // Use promise with timeout to prevent hanging
      const playPromise = successSound.play();
      if (playPromise) {
        playPromise.catch(error => {
          console.error("Failed to play success sound:", error);
          // Try once more with user interaction already present
          setTimeout(() => successSound.play().catch(e => console.error("Retry failed:", e)), 100);
        });
      }
    }
  }
  
  // Show mismatch modal with product details - using cached elements
  function showMismatchModal(customerProduct, ourProduct) {
    const modal = domCache['mismatchModal'];
    if (!modal) {
      console.error("Mismatch modal not found in DOM cache");
      return;
    }
    
    // Get message element - don't use cache for this infrequently used element
    const message = document.getElementById('mismatchMessage');
    if (message) {
      message.innerHTML = `
        <div class="text-left">
          <div class="mb-2">„ÅäÂÆ¢ÊßòË£ΩÂìÅÁï™Âè∑: <span class="font-bold">${customerProduct}</span></div>
          <div>Á§æÂÜÖË£ΩÂìÅÁï™Âè∑: <span class="font-bold">${ourProduct}</span></div>
        </div>
      `;
    }
    
    modal.style.display = 'flex';
  }
  
  // Close mismatch modal and reset state - using cached elements
  window.closeMismatchModal = function() {
    const modal = domCache['mismatchModal'];
    const alertSound = domCache['alert-sound'];
    const successSound = domCache['success-sound'];
    
    if (modal) modal.style.display = 'none';
    document.body.classList.remove('flash-red');
    
    // Stop all sounds
    if (alertSound) {
      alertSound.muted = true;
      alertSound.pause();
      alertSound.currentTime = 0;
    }
    
    if (successSound) {
      successSound.muted = true;
      successSound.pause();
      successSound.currentTime = 0;
    }
    
    clearFields();
  }
  
  // Handle ESC key to close modals
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      const mismatchModal = document.getElementById('mismatchModal');
      if (mismatchModal.style.display === 'flex') {
        closeMismatchModal();
      }
    }
  });

  function clearFields() {
    // Use cached DOM elements for better performance
    if (domCache['customerQR']) domCache['customerQR'].value = "";
    if (domCache['ourQR']) domCache['ourQR'].value = "";
    if (domCache['result']) domCache['result'].textContent = "";
    
    // Reset visual alerts if any
    document.body.classList.remove('flash-red');
    
    // Stop any playing sounds
    if (domCache['alert-sound']) {
      domCache['alert-sound'].pause();
      domCache['alert-sound'].currentTime = 0;
      domCache['alert-sound'].muted = true;
    }
    
    if (domCache['success-sound']) {
      domCache['success-sound'].pause();
      domCache['success-sound'].currentTime = 0;
      domCache['success-sound'].muted = true;
    }
    
    // Clear saved form data - use deferred saving for better performance
    setTimeout(() => {
      saveFormData({
        customerQR: "",
        ourQR: "",
        customerType: domCache['customerSelect'] ? domCache['customerSelect'].value : 'tn'
      });
    }, 0);
    
    updateScanStatus("Ê¨°„ÅÆ„Çπ„Ç≠„É£„É≥„ÇíÂæÖÊ©ü‰∏≠...");
  }

  // Optimized global keyboard event listener for bluetooth scanner
  let lastKeyTime = 0;
  const MAX_SCAN_GAP = 30; // ms between keystrokes for fast scanner (increased slightly)
  let spaceCount = 0; // Track spaces for detecting multi-part QR codes
  
  document.addEventListener('keydown', (e) => {
    const now = performance.now();
    
    // Ignore if user is typing in an input field manually
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
      return;
    }

    // Handle Enter key (end of scan) immediately for better responsiveness
    if (e.key === 'Enter') {
      e.preventDefault();
      if (scanBuffer.trim()) {
        // If the buffer has content, process immediately
        console.log('Scan complete with ENTER key, buffer:', scanBuffer);
        processScannedQR(scanBuffer.trim());
        scanBuffer = "";
        spaceCount = 0;
        clearTimeout(scanTimeout); // Clear any pending timeouts
      }
      return;
    }

    // Add character to buffer if it's printable
    if (e.key.length === 1) {
      e.preventDefault();
      
      // Check if this is the first character or part of rapid sequence
      const keyGap = now - lastKeyTime;
      
      // If it's been a while since the last keystroke, this might be a new scan
      // Clear buffer if it's likely a new scan starting
      if (keyGap > 1000 && scanBuffer.length > 0) {
        console.log(`Clearing stale scan buffer (${keyGap}ms gap)`);
        scanBuffer = "";
        spaceCount = 0;
      }
      
      // Track spaces to detect multi-part QR codes (like customer format with 2 spaces)
      if (e.key === ' ') {
        spaceCount++;
        console.log(`Space detected (${spaceCount} spaces so far)`);
      }
      
      // Add character to buffer
      scanBuffer += e.key;
      lastKeyTime = now;
      
      // Customer QR codes can be quite long, but we need to make sure we catch them
      // Log buffer status periodically for debugging
      if (scanBuffer.length % 10 === 0) {
        console.log(`Scan buffer length: ${scanBuffer.length}`);
      }
      
      // For the specific customer QR format with 2 spaces, we can detect completion
      // based on pattern: "numbers    alphanumeric    0019GN..."
      if (spaceCount === 2 && scanBuffer.includes('0019GN')) {
        console.log('Customer QR pattern detected, processing immediately');
        // Give a little time for the last characters to arrive
        clearTimeout(scanTimeout);
        scanTimeout = setTimeout(() => {
          console.log('Processing detected customer QR:', scanBuffer);
          processScannedQR(scanBuffer.trim());
          scanBuffer = "";
          spaceCount = 0;
        }, 50); // Short timeout to ensure complete scan
        return;
      }
      
      // Set a timeout to process the QR code after a short delay
      clearTimeout(scanTimeout);
      
      // Set a shorter timeout if keystrokes are coming rapidly (scanner-like)
      // For customer QRs which are longer, we need a slightly longer timeout
      const timeoutDuration = keyGap < MAX_SCAN_GAP ? 150 : SCAN_TIMEOUT; // Increased from 100ms to 150ms
      
      scanTimeout = setTimeout(() => {
        if (scanBuffer.trim()) {
          console.log('Scan timeout triggered, buffer:', scanBuffer);
          processScannedQR(scanBuffer.trim());
          scanBuffer = "";
          spaceCount = 0;
        }
      }, timeoutDuration);
    }
  });

  // Initialize
  updateScanStatus("„Çπ„Ç≠„É£„É≥ÂæÖÊ©ü‰∏≠...");

  // Show pending logs count if any
  if (pendingLogs.length > 0) {
    console.log(`${pendingLogs.length} logs pending upload`);
  }

  // Periodic retry for pending logs (less frequent - every 60 seconds)
  setInterval(() => {
    if (isOnline && pendingLogs.length > 0 && !uploadQueueProcessing) {
      console.log(`Periodic upload check: ${pendingLogs.length} logs pending`);
      
      // Throttle background uploads based on queue size
      const now = Date.now();
      const timeSinceLastUpload = now - lastUploadTime;
      
      // More aggressive upload schedule based on pending logs size
      const uploadInterval = pendingLogs.length > 50 ? 10000 : 
                            pendingLogs.length > 20 ? 20000 : 
                            MIN_UPLOAD_INTERVAL;
      
      if (timeSinceLastUpload > uploadInterval) {
        scheduleBackgroundUpload();
      }
    }
  }, 60000);

  // Learning mode functionality
  window.openLearningMode = function() {
    window.location.href = 'qrLearning.html';
  };

  // Expose functions for manual button click and debugging
  window.compareQRs = compareQRs;
  window.clearFields = clearFields;
  window.processPendingLogs = processPendingLogs;
  window.getPendingLogsCount = () => pendingLogs.length;
  
  // Add debugging function for upload status
  window.getUploadStatus = () => {
    return {
      isOnline: isOnline,
      pendingCount: pendingLogs.length,
      isUploading: uploadQueueProcessing,
      lastUploadTime: lastUploadTime ? new Date(lastUploadTime).toLocaleTimeString() : 'never',
      timeUntilNextUpload: lastUploadTime ? 
        Math.max(0, MIN_UPLOAD_INTERVAL - (Date.now() - lastUploadTime)) + 'ms' : 
        'ready'
    };
  };
});


  </script>
</body>
</html>



